{
  "comments": [
    {
      "key": {
        "uuid": "8ea37d9e_28c1995a",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 605,
      "author": {
        "id": 1000548
      },
      "writtenOn": "2019-07-29T19:41:47Z",
      "side": 1,
      "message": "Do we need to take lock here ? \n\nIs there a chance that omci-indication will be received before ONT is activated by OLT as part of discovery procedure ? This helps when adapter restarts after activated ONU ?",
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "de0175d6_9868f432",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 605,
      "author": {
        "id": 1000436
      },
      "writtenOn": "2019-07-29T20:09:17Z",
      "side": 1,
      "message": "from my understanding with golang maps it needs a lock even if its a reader.  as other threads may be adding items to this map there is a chance of corruption.\n\nSee this: https://stackoverflow.com/questions/11063473/map-with-concurrent-access",
      "parentUuid": "8ea37d9e_28c1995a",
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d488b352_6314db92",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 623,
      "author": {
        "id": 1000548
      },
      "writtenOn": "2019-07-29T19:41:47Z",
      "side": 1,
      "message": "Do we need to take lock again here ? Or we can still hold same the lock taken above and release once updated database ?",
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f8360fe9_d43f241a",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 623,
      "author": {
        "id": 1000436
      },
      "writtenOn": "2019-07-29T20:09:17Z",
      "side": 1,
      "message": "I tried to avoid keeping locks locked when making coreProxy (network) calls.  if its all local/in memory work keeping the lock longer seems safe.",
      "parentUuid": "d488b352_6314db92",
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb31d33a_ea129a7e",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 1000548
      },
      "writtenOn": "2019-07-30T12:41:34Z",
      "side": 1,
      "message": "Here in-order to receive OMCI indications from the device , ONU should have been already activated as part of ONU-DISCOVERY procedure and onu-cache should be readily  available. Ideally this situation should never hit. \n\nAlso it is good to not taking lock during OMCI processing which will impact performance",
      "range": {
        "startLine": 605,
        "startChar": 0,
        "endLine": 627,
        "endChar": 24
      },
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0c97965e_5575a496",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 1000436
      },
      "writtenOn": "2019-07-30T14:33:17Z",
      "side": 1,
      "message": "for any single onu, referenced by the one key in the map, yes it should be beyond discovery.  but other onus in different states being worked by other goroutines as part of this olt device handler will also access this this map, adding new keys.  i.e other onu in discovery state adding to the samme map while being read from here could cause corruption.",
      "parentUuid": "fb31d33a_ea129a7e",
      "range": {
        "startLine": 605,
        "startChar": 0,
        "endLine": 627,
        "endChar": 24
      },
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3b12b4a4_735d91b2",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 1000548
      },
      "writtenOn": "2019-07-30T20:16:41Z",
      "side": 1,
      "message": "Yes Matt , i agree that go-lang maps does not guarantee multiple writer/reader operations concurrently without locking mechanisms \n\nHere the main reason we are caching is to avoid sync call to core to get child device so that it  shall be perform better since we deal with southbound indications on which we don\u0027t have control. But we end-up in same situation by performing many locks/unlocks \n\ni am thinking how to avoid locks here as it will hit impact performance.",
      "parentUuid": "0c97965e_5575a496",
      "range": {
        "startLine": 605,
        "startChar": 0,
        "endLine": 627,
        "endChar": 24
      },
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "03727a36_7d2999f4",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 627,
      "author": {
        "id": 1000436
      },
      "writtenOn": "2019-07-30T20:50:11Z",
      "side": 1,
      "message": "for the sake of progress ill pull some of the locks out.  given this function is not in a separate thread it *should* be fine (the readindications thread handles it all).  \n\nideally though all functions off the readIndications thread should be in their own thread, but we can tweak performance later.",
      "parentUuid": "3b12b4a4_735d91b2",
      "range": {
        "startLine": 605,
        "startChar": 0,
        "endLine": 627,
        "endChar": 24
      },
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0d2a2ae6_64ded8e7",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 750,
      "author": {
        "id": 1000548
      },
      "writtenOn": "2019-07-29T19:41:47Z",
      "side": 1,
      "message": "This defer function will be called even after successfully added ONU which is not right(Duplicate discovery  will be processed ) . discOnus cache  shall  be deleted only when ONU is deactivated at OLT OR deleted explicitly when failed to activate ONU",
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "46f19b2e_08a1b283",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 750,
      "author": {
        "id": 1000436
      },
      "writtenOn": "2019-07-29T20:09:17Z",
      "side": 1,
      "message": "the delete was already here so i kept it.  i think it makes sense to keep this populated as you say until the olt hardware is restarted.  \n\nHow about remove this defer altogether?",
      "parentUuid": "0d2a2ae6_64ded8e7",
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "16731d34_df68a98e",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 750,
      "author": {
        "id": 1000548
      },
      "writtenOn": "2019-07-30T12:41:34Z",
      "side": 1,
      "message": "Yes we will remove this defer function , and delete explicitly wherever needed",
      "parentUuid": "46f19b2e_08a1b283",
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a21ac25_b1c125c5",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 750,
      "author": {
        "id": 1000548
      },
      "writtenOn": "2019-07-30T20:16:41Z",
      "side": 1,
      "message": "we need to take care of deleting onu cache in appropriate situations  ex: ONT is deactivated , ONT activation is failed etc.",
      "parentUuid": "16731d34_df68a98e",
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c2c15dac_894d7d93",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 770,
      "author": {
        "id": 1000548
      },
      "writtenOn": "2019-07-29T19:41:47Z",
      "side": 1,
      "message": "why do we need to take lock here since dh.discOnus[sn] is already updated hence at any point of time one discovery will be processed  fully ?",
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ca9968f4_c43d0449",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 770,
      "author": {
        "id": 1000436
      },
      "writtenOn": "2019-07-29T20:09:17Z",
      "side": 1,
      "message": "part of the reason for all the locking is now onuDiscIndication starts its own thread per discovery.  this is to prevent the whole of readIndications thread from being put to sleep, pausing all indications.\n\ngetONUID for multiple concurrent discoveries/activations returned the same onu id for multiple onu being activated at the same time, breaking many things.  hence the lock",
      "parentUuid": "c2c15dac_894d7d93",
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "44f74b90_74df61dd",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 797,
      "author": {
        "id": 1000548
      },
      "writtenOn": "2019-07-29T19:41:47Z",
      "side": 1,
      "message": "why do we need to take lock here since dh.discOnus[sn] is already updated hence  at this  point of time only one discovery will be processed? Any other specific scenario ?",
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "91577f0f_a64f4650",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 802,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2019-07-31T21:23:05Z",
      "side": 1,
      "message": "isn\u0027t this already checked by \"if _, ok :\u003d dh.discOnus[sn]; ok {\" line?",
      "range": {
        "startLine": 798,
        "startChar": 1,
        "endLine": 802,
        "endChar": 2
      },
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "659eb465_b4d6c45a",
        "filename": "adaptercore/device_handler.go",
        "patchSetId": 1
      },
      "lineNbr": 817,
      "author": {
        "id": 1000436
      },
      "writtenOn": "2019-07-29T20:13:51Z",
      "side": 1,
      "message": "if onuDiscIndication is not its own goroutine, this puts all of readIndications to sleep.  pausing all discoveries, omci, etc.",
      "range": {
        "startLine": 817,
        "startChar": 1,
        "endLine": 817,
        "endChar": 28
      },
      "revId": "a8d115a31b347c5feca5db84357a7239618fde44",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    }
  ]
}