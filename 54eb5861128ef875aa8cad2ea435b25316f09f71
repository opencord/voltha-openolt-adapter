{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1c3782b7_a05a49ec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000127
      },
      "writtenOn": "2022-01-22T00:24:02Z",
      "side": 1,
      "message": "hardware test\nfunctional tests",
      "revId": "54eb5861128ef875aa8cad2ea435b25316f09f71",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15a3b40e_14e0291c",
        "filename": "internal/pkg/core/openolt_flowmgr.go",
        "patchSetId": 1
      },
      "lineNbr": 2002,
      "author": {
        "id": 1000405
      },
      "writtenOn": "2022-01-24T09:10:20Z",
      "side": 1,
      "message": "As you know, we are deleting gemports from the OLT when we call the RemoveSchedulerQueues method. Now, you are deleting a gem port from the cache and sending a gemPortDelete request to the ONU adapter before we delete the gem port from OLT. So, what if the gemport removal operation fails on the OLT? There will be a synchronization problem (ONU adapter will remove the gemport, we already freed the gemport-id but, the gemport will be on the OLT). After that, when we want to provision a new service to another ONU on the same pon port, it will always fail because of the gemport-id allocation. (OLT still uses the gemport for the previous ONU). How will we solve this problem?",
      "revId": "54eb5861128ef875aa8cad2ea435b25316f09f71",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a74d035_11a7dd60",
        "filename": "internal/pkg/core/openolt_flowmgr.go",
        "patchSetId": 1
      },
      "lineNbr": 2002,
      "author": {
        "id": 1000127
      },
      "writtenOn": "2022-01-24T18:57:53Z",
      "side": 1,
      "message": "Got it. But it is unclear to me to how this is different in terms of OLT failure handling from previous code. This patch is addressing a different issue where the TCONT-Delete request was not sent to ONU when ONU instance was single-instance for a multi-uni scenario.\nI think some improvements are needed in handling failure scenarios in the code that exists which we should address in different jira. Or did I understand something wrong, meaning did I introduce some issue?",
      "parentUuid": "15a3b40e_14e0291c",
      "revId": "54eb5861128ef875aa8cad2ea435b25316f09f71",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e36c0103_2779e32e",
        "filename": "internal/pkg/core/openolt_flowmgr.go",
        "patchSetId": 1
      },
      "lineNbr": 2002,
      "author": {
        "id": 1000405
      },
      "writtenOn": "2022-01-25T13:37:32Z",
      "side": 1,
      "message": "No, you didn\u0027t introduce the issue. I just realized the problem while I was reading your code changes. It would be great if we create a new Jira. \nHowever, I think there is another problem with the changes you made. I will try to explain the problem with an example:\n1. TpID 64: ONU: single-instance, UNI: single-instance\n2. We provision service to PON1 - ONU1 - UNI1 with TpID 64. It uses Tcont 1024, Gem 1024.\n3. We provision the same service to PON1 - ONU1 - UNI2 with TpID 64. It uses Tcont 1024, Gem 1025. (same Tcont usage because of \"single-instance\" definition)\n4. We remove the service from PON1 - ONU1 - UNI2 with TpID 64. We will delete TechProfileInstance, free Gem 1025 and, send the sendDeleteGemPortToChild request to the ONU adapter. The code will call the \"isAllocUsedByAnotherUNI\" method and get true (allocExists) because of the PON1 - ONU1- UNI1 alignment. We won\u0027t delete GEM 1025 from the OLT.\n5. We provision the same service to PON1 - ONU2 - UNI1 with TpID 64 (or 65, I think it doesn\u0027t matter). OLT adapter will try to assign Tcont 1025, Gem 1025. (Gem 1025 is free). OLT is using Gem 1025 for PON1 - ONU1 - UNI1. So, the CreateQueue request will fail.\nWhat do you think? Am I missing something?",
      "parentUuid": "4a74d035_11a7dd60",
      "revId": "54eb5861128ef875aa8cad2ea435b25316f09f71",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43d935d4_f13f50f3",
        "filename": "internal/pkg/core/openolt_flowmgr.go",
        "patchSetId": 1
      },
      "lineNbr": 2002,
      "author": {
        "id": 1000127
      },
      "writtenOn": "2022-01-25T20:16:29Z",
      "side": 1,
      "message": "Very good point. What you describe is an issue. I tried to address this in the next patch where I clear the queues immediately. The schedulers are cleared later when no references are found for the TP. Basically the RemoveSchedulerQueues is split into RemoveScheduler and RemoveQueues.\nAlso for another problem you describe w.r.to ONU and OLT not being in the same state if any failures happen at the OLT, I created jira VOL-4563.",
      "parentUuid": "e36c0103_2779e32e",
      "revId": "54eb5861128ef875aa8cad2ea435b25316f09f71",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "958b8322_c89093e0",
        "filename": "internal/pkg/core/openolt_flowmgr.go",
        "patchSetId": 1
      },
      "lineNbr": 2002,
      "author": {
        "id": 1000127
      },
      "writtenOn": "2022-01-27T04:07:33Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "43d935d4_f13f50f3",
      "revId": "54eb5861128ef875aa8cad2ea435b25316f09f71",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388"
    }
  ]
}